#!/usr/bin/env bash
set -euo pipefail

if [ $# -ne 1 ]; then
  echo "Usage: $0 <git-repo-url|local-path>"
  exit 1
fi

INPUT=$1

# helper: true if file is text (no NULs)
_is_text_file() {
  [ -f "$1" ] || return 1
  grep -Iq . "$1" >/dev/null 2>&1
}

# determine working dir and prefix
if [ -d "$INPUT" ]; then
  CANDIDATE=$(realpath "$INPUT")
  CLEANUP=false

  if git -C "$CANDIDATE" rev-parse --is-inside-work-tree &>/dev/null; then
    REPO_ROOT=$(git -C "$CANDIDATE" rev-parse --show-toplevel)
    PREFIX=${CANDIDATE#"$REPO_ROOT"/}
  else
    REPO_ROOT=$CANDIDATE
    PREFIX=""
  fi
else
  REPO_ROOT=$(mktemp -d)
  CLEANUP=true
  git clone --depth=1 "$INPUT" "$REPO_ROOT"
  PREFIX=""
fi

# cleanup temp clone on exit
trap '[[ $CLEANUP = true ]] && rm -rf "$REPO_ROOT"' EXIT

# dump only text files, respecting .gitignore when in Git
if git -C "$REPO_ROOT" rev-parse --is-inside-work-tree &>/dev/null; then
  cd "$REPO_ROOT"
  if [ -n "$PREFIX" ]; then
    git ls-files --cached --others --exclude-standard -- "$PREFIX" \
      | sed "s#^$PREFIX/##" \
      | sort \
      | while IFS= read -r rel; do
          path="$CANDIDATE/$rel"
          _is_text_file "$path" || continue

          printf '\n<<< FILE: %s >>>\n' "$rel"
          cat "$path"
          printf '\n<<< END OF %s >>>\n' "$rel"
        done
  else
    git ls-files --cached --others --exclude-standard \
      | sort \
      | while IFS= read -r rel; do
          path="$REPO_ROOT/$rel"
          _is_text_file "$path" || continue

          printf '\n<<< FILE: %s >>>\n' "$rel"
          cat "$path"
          printf '\n<<< END OF %s >>>\n' "$rel"
        done
  fi
else
  find "$REPO_ROOT" -type f ! -path "*/.git/*" \
    | sort \
    | while IFS= read -r file; do
        _is_text_file "$file" || continue
        rel=${file#"$REPO_ROOT"/}

        printf '\n<<< FILE: %s >>>\n' "$rel"
        cat "$file"
        printf '\n<<< END OF %s >>>\n' "$rel"
      done
fi
